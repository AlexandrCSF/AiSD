# AiSD
Таски по АиСД второй семестр

[Task 1](https://github.com/RyanGosling2008/AiSD/tree/main/Task%201) 
23.Описать в виде класса калькулятор для расчета платежей по кредиту. Кредит задается параметрами: сумма кредита, 
срок кредита в месяцах, фиксированная процентная ставка, способ погашения кредита (дифференцированные платежи / аннуитетные платежи). 
Класс должен позволять задать каждый их этих параметров, а также рассчитать сумму платежей в n-ый по счету месяц, а также общую суммы платежей по кредиту. 
Интерфейс может быть консольным.

[Task 2](https://github.com/RyanGosling2008/AiSD/tree/main/Task%202)
30.Реализовать для списка сортировку вставками

[Task 3](https://github.com/RyanGosling2008/AiSD/tree/main/Task%203)
22.Смоделировать следующую игру. Берется колода карт, перемешивается. Верхняя карта кладется на стол. Далее берется следующая карта, если она той же масти или достоинства, то кладется на карту на столе, в противном случае перекладывается вниз стопки карт. Действия продолжаются, пока в стопке карт остаются карты, которые можно положить на самую верхнюю карту на столе по описанным правилам. Необходимо найти, а) сколько будет сделано ходов, б) какие карты и в каком порядке окажутся на столе, в) какие карты и в каком порядке останутся в стопке карт.

[Task 3(2)](https://github.com/RyanGosling2008/AiSD/tree/main/Task%203%20(2)) 
Тот же самый таск 3, но сделанный на основе уже встроенного Стека

[Task 4](https://github.com/RyanGosling2008/AiSD/tree/main/Task%204)
1.Написать программу, которая наглядно иллюстрирует эффективность следующих методов сортировки: –пузырьковая; –шейкерная (перемешиванием).
Для этого необходимо провести сравнение этих сортировок по количеству сравнений и по количеству обменов (добавить подсчет сравнений и обменов в реализацию сортировок). 
Для этого построить графики зависимостей данных величин от количества элементов массива.

[Task 5](https://github.com/RyanGosling2008/AiSD/tree/main/Task%205) 
2.Реализовать функцию, которая изменить двоичное дерево следующим образом: Удалит все внутренние узлы, у которых есть только один потомок 
(соответственно, потомки должны занять место удаляемых узлов).

[Task 6](https://github.com/RyanGosling2008/AiSD/tree/main/Task%206) 
15.Получить список слов, которые встречаются в тексте ровно N раз (N задается пользователем).
Одни и те же слова в различной форме считаются разными словами. В качестве тестовых данных использовать литературные произведения (большие по объему тексты).

[Task 6_Self_made](https://github.com/RyanGosling2008/AiSD/tree/main/Task6_Self_made)
Тот же самый Task 6, но сделанный с помощью собственной HashMap, а не встроенной в Java.

[Task 7](https://github.com/RyanGosling2008/AiSD/tree/main/Task%207)
2.Определить, является ли связанным заданный граф (рекурсивная реализация).
